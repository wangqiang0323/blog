---
title: 事件循环
top: false
cover: false
toc: true
mathjax: true
abbrlink: 13214
date: 2021-03-29 10:36:56
password:
summary: 注意理解执行栈，宏任务，微任务
tags: 
 - 深入
categories: Javascript
---

# 事件循环

### 基础概念
首先得了解javascript是单线程的，那么单线程遇到request请求肯定会阻塞任务，那js是怎么处理的呢？

这就得了解js的一些异步函数。如Promise MutationObserver, setImmediate, setTimeout。

了解Vue的同学，应该知道$nextTick就是通过上述异步函数实现的。

那么异步函数为什么不会阻塞呢，这就是下面要讲到的js事件循环机制。

我们先记住两个概念：宏任务和微任务

以下事件属于宏任务：

- setInterval()
- setTimeout()

以下事件属于微任务

-  new Promise()
-  new MutaionObserver()

然后看下面的例子1

### 例子1 
```
console.log(3)

setTimeout(() => { // 第一个
  console.log(1)
})

new Promise((resolve) => {
  console.log(4)
  resolve()
  setTimeout(() => { // 第二个
     console.log(2)
     setTimeout(() => { // 第三个
	     console.log(8)
	  })
  })
}).then(() => {
  console.log(6)
  setTimeout(() => { // 第四个
     console.log(7)
  })
})

console.log(5)  
```

执行结果为： 3 4 5 6 1 2 7 8。

看到执行结果，就得问问是为什么呢？先说一个结论，微任务优先宏任务执行。

- 众所周知，js是按顺序执行的。第一个3没有问题，碰到setTimeout和Promise.then会挂起放到异步队列中，等有了返回结果再拿出来执行。 那么接着打印4和5。
- 接着就是异步队列中存放的setTimeou和Promise.then了，Promise.then属于微任务，优先宏任务执行，接着打印6。
- 剩下的就是setTimeout了，他们的执行顺序和放入异步队列的顺序相关（因为都没有等待时间）。1和2很好理解，7和8呢？还是因为微任务Promise.then比第二个setTimeout先执行，所以第四个setTimeout比第三个setTimeout先执行，即先有返回结果。

### 深入理解
> 1. 执行栈与事件队列  
> 当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。  
> 我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。  
> 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。  
> 一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。  
> 以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。  
> js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行“执行栈”中的其他任务。**当一个异步事件返回结果后**，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。**被放入事件队列不会立刻执行其回调**，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。


### 思考
```
console.log(1)

setTimeout(() => {
  console.log(6)
})

new Promise(resolve => {
  console.log(2)
  setTimeout(() => {
    console.log(3)
    resolve()             // resolve放在这里时，执行顺序为 1 2 5 6 3 4
  })
  // resolve()           // resolve放在这里时，执行顺序为 1 2 5 4 6 3

}).then(() => {
  console.log(4)
})

console.log(5)
```

### 总结
1. js引擎遇到异步事件会将其挂起，继续执行“执行栈”中的同步代码；
2. 当异步事件有返回结果后，才会加入到事件队列（与当前执行栈不同的另一个队列）中；
3. 当主线程为闲置状态时，才会查找事件队列是否有任务；如果有，取第一个加入执行栈中执行其中同步代码，如此循环；